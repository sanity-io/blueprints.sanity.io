<bp-h1>Values</bp-h1>
<p>
    Values are variables that developers can define for reuse within the
    Blueprint manifest. They represent configurable parameters, constants, and
    dynamic configurations that can be referenced throughout your infrastructure
    definition.
</p>
<p>
    Values can then be referenced throughout your Blueprint template using
    interpolation syntax like <code>$.values.environment</code> or
    <code>$.values.instance_count</code>.
</p>
<bp-code>
  <bp-code-json slot=json>
{
  "resources": [
    {
      "name": "sanetti-inc",
      "type": "sanity.project"
    },
    {
      "name": "update-cdn",
      "type": "sanity.function.document-mutation",
      "project": "$.resources.sanetti-inc"
    }
  ]
}
  </bp-code-json>
  <bp-code-ts slot=ts>
import {defineBlueprint, defineProject, defineDataset} from '@sanity/blueprints'

export default defineBlueprint({
  resources: [
    defineProject({ 
      name: 'sanetti-inc' 
    }),
    defineDataset({ 
      name: 'blog', 
      project: '$.resources.sanetti-inc' 
    })
  ]
})
  </bp-code-ts>
</bp-code>
<bp-h2>Features of Values</bp-h2>
<ul>
    <li>
        Template reusability: Values allow the same Blueprint template to be
        used across different environments (development, staging, production) by
        simply changing the Value definitions rather than duplicating entire
        templates.
    </li>
    <li>
        Consistency: by defining configuration once in Values and referencing it
        multiple times, you ensure consistent naming, sizing, and configuration
        across all related resources.
    </li>
    <li>
        Maintainability: when you need to change a configuration that's used in
        multiple places, you only need to update the Value definition once
        rather than hunting through the entire template.
    </li>
    <li>
        Environment parameterization: Values enable clean separation between
        your infrastructure definition and environment-specific configuration,
        making it easy to deploy the same Blueprint with different settings.
    </li>
    <li>
        Reduced duplication: Instead of repeating the same strings, numbers, or
        configuration blocks throughout your template, Values eliminate
        redundancy and potential inconsistencies.
    </li>
    <li>
        Dynamic configuration: Values can be populated from external sources
        like parameter files, environment variables, or external configuration
        systems, enabling flexible deployment workflows.
    </li>
    <li>
        Documentation and clarity: well-named Values serve as self-documenting
        configuration, making it clear what can be customized and what the
        different options mean.
    </li>
</ul>
<p>
    This approach transforms Blueprint templates from static infrastructure
    definitions into flexible, parameterized templates that can adapt to
    different requirements while maintaining consistency and reducing errors.
</p>
